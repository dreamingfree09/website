#!/usr/bin/env node
/*
  scripts/curate-chat-rooms.js

  Purpose:
  - Rename existing auto-generated public rooms (e.g. public_*) into a consistent, purposeful set.
  - Ensure a set of default public rooms exists, including voice-1..voice-5.

  Safety:
  - Does NOT delete rooms or messages.
  - Only renames public rooms whose names look auto-generated (public_*).

  Usage:
    node scripts/curate-chat-rooms.js

  Notes:
  - This script is idempotent. Re-running should result in the same final set.
*/

const mongoose = require('mongoose');

const ChatRoom = require('../models/ChatRoom');

const defaultMongoUri = 'mongodb://localhost:27017/piqniq';

const TARGET_PUBLIC_ROOMS = [
  'lobby',
  'help',
  'announcements',
  'introductions',
  'general',
  'projects',
  'study',
  'resources',
  'career',
  'feedback',
  // “Voice” placeholders (text rooms by default, can be used for voice coordination)
  'voice-1',
  'voice-2',
  'voice-3',
  'voice-4',
  'voice-5'
];

function looksAutoGeneratedPublicRoomName(name) {
  const s = String(name || '').trim();
  return /^public[_-][a-z0-9]{8,}$/i.test(s);
}

async function connect() {
  const mongoUri = process.env.MONGODB_URI || defaultMongoUri;
  await mongoose.connect(mongoUri);
  return mongoUri;
}

async function ensureRoomExists(name) {
  const existing = await ChatRoom.findOne({ name });
  if (existing) return { room: existing, created: false };

  const room = await ChatRoom.create({
    name,
    isPrivate: false,
    createdBy: undefined,
    lastActiveAt: new Date()
  });
  return { room, created: true };
}

async function renameRoom(roomId, nextName) {
  await ChatRoom.updateOne(
    { _id: roomId },
    { $set: { name: nextName } }
  );
}

async function main() {
  const mongoUri = await connect();

  const allPublicRooms = await ChatRoom.find({ isPrivate: false }).sort({ lastActiveAt: -1 });
  const existingNames = new Set(allPublicRooms.map((r) => r.name));

  // Candidate rooms to rename (auto-generated public_* rooms), most-active first.
  const renameCandidates = allPublicRooms.filter((r) => looksAutoGeneratedPublicRoomName(r.name));

  const actions = {
    created: [],
    renamed: [],
    unchanged: [],
    extrasRenamed: []
  };

  // 1) Ensure our target room set exists, preferably by renaming candidates first.
  for (const desiredName of TARGET_PUBLIC_ROOMS) {
    if (existingNames.has(desiredName)) {
      actions.unchanged.push(desiredName);
      continue;
    }

    const candidate = renameCandidates.shift();
    if (candidate) {
      await renameRoom(candidate._id, desiredName);
      actions.renamed.push({ from: candidate.name, to: desiredName });
      existingNames.add(desiredName);
      continue;
    }

    const { created } = await ensureRoomExists(desiredName);
    if (created) actions.created.push(desiredName);
    existingNames.add(desiredName);
  }

  // 2) Any remaining auto-generated rooms get a stable, human-readable name.
  //    (Keeps them from cluttering the UI with random IDs, without deleting history.)
  let extraIndex = 1;
  for (const remaining of renameCandidates) {
    let extraName = `extra-${extraIndex}`;
    while (existingNames.has(extraName)) {
      extraIndex += 1;
      extraName = `extra-${extraIndex}`;
    }

    await renameRoom(remaining._id, extraName);
    actions.extrasRenamed.push({ from: remaining.name, to: extraName });
    existingNames.add(extraName);
    extraIndex += 1;
  }

  // Output summary (human + script-friendly)
  const summary = {
    mongoUri,
    targets: TARGET_PUBLIC_ROOMS.length,
    publicRoomsBefore: allPublicRooms.length,
    renamedCount: actions.renamed.length,
    createdCount: actions.created.length,
    extrasRenamedCount: actions.extrasRenamed.length
  };

  // eslint-disable-next-line no-console
  console.log(JSON.stringify({ ok: true, summary, actions }, null, 2));

  await mongoose.disconnect();
}

main().catch(async (err) => {
  // eslint-disable-next-line no-console
  console.error('curate-chat-rooms failed:', err);
  try {
    await mongoose.disconnect();
  } catch {
    // ignore
  }
  process.exit(1);
});
